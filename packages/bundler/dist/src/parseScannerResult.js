"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseScannerResult = void 0;
const contracts_1 = require("@account-abstraction/contracts");
const utils_1 = require("ethers/lib/utils");
const utils_2 = require("./utils");
const util_1 = require("util");
const debug_1 = __importDefault(require("debug"));
const moduleUtils_1 = require("./modules/moduleUtils");
const ethers_1 = require("ethers");
const types_1 = require("./types");
const Types_1 = require("./modules/Types");
const debug = (0, debug_1.default)('aa.handler.opcodes');
/**
 * parse all call operation in the trace.
 * notes:
 * - entries are ordered by the return (so nested call appears before its outer call
 * - last entry is top-level return from "simulateValidation". it as ret and rettype, but no type or address
 * @param tracerResults
 */
function parseCallStack(tracerResults) {
    const abi = Object.values([
        ...types_1.TestOpcodesAccount__factory.abi,
        ...types_1.TestOpcodesAccountFactory__factory.abi,
        ...types_1.TestStorageAccount__factory.abi,
        ...contracts_1.SenderCreator__factory.abi,
        ...contracts_1.IEntryPoint__factory.abi,
        ...contracts_1.IPaymaster__factory.abi
    ].reduce((set, entry) => {
        const key = `${entry.name}(${entry.inputs.map(i => i.type).join(',')})`;
        // console.log('key=', key, keccak256(Buffer.from(key)).slice(0,10))
        return Object.assign(Object.assign({}, set), { [key]: entry });
    }, {}));
    const xfaces = new utils_1.Interface(abi);
    function callCatch(x, def) {
        try {
            return x();
        }
        catch (_a) {
            return def;
        }
    }
    const out = [];
    const stack = [];
    tracerResults.calls
        .filter(x => !x.type.startsWith('depth'))
        .forEach(c => {
        var _a, _b;
        if (c.type.match(/REVERT|RETURN/) != null) {
            const top = (_a = stack.splice(-1)[0]) !== null && _a !== void 0 ? _a : {
                type: 'top',
                method: 'validateUserOp'
            };
            const returnData = c.data;
            if (top.type.match(/CREATE/) != null) {
                out.push({
                    to: top.to,
                    from: top.from,
                    type: top.type,
                    method: '',
                    return: `len=${returnData.length}`
                });
            }
            else {
                const method = callCatch(() => xfaces.getFunction(top.method), top.method);
                if (c.type === 'REVERT') {
                    const parsedError = callCatch(() => xfaces.parseError(returnData), returnData);
                    out.push({
                        to: top.to,
                        from: top.from,
                        type: top.type,
                        method: method.name,
                        value: top.value,
                        revert: parsedError
                    });
                }
                else {
                    const ret = callCatch(() => xfaces.decodeFunctionResult(method, returnData), returnData);
                    out.push({
                        to: top.to,
                        from: top.from,
                        type: top.type,
                        method: (_b = method.name) !== null && _b !== void 0 ? _b : method,
                        return: ret
                    });
                }
            }
        }
        else {
            stack.push(c);
        }
    });
    // TODO: verify that stack is empty at the end.
    return out;
}
/**
 * slots associated with each entity.
 * keccak( A || ...) is associated with "A"
 * removed rule: keccak( ... || ASSOC ) (for a previously associated hash) is also associated with "A"
 *
 * @param stakeInfoEntities stake info for (factory, account, paymaster). factory and paymaster can be null.
 * @param keccak array of buffers that were given to keccak in the transaction
 */
function parseEntitySlots(stakeInfoEntities, keccak) {
    // for each entity (sender, factory, paymaster), hold the valid slot addresses
    // valid: the slot was generated by keccak(entity || ...)
    const entitySlots = {};
    keccak.forEach(k => {
        Object.values(stakeInfoEntities).forEach(info => {
            var _a;
            const addr = (_a = info === null || info === void 0 ? void 0 : info.addr) === null || _a === void 0 ? void 0 : _a.toLowerCase();
            if (addr == null)
                return;
            const addrPadded = (0, moduleUtils_1.toBytes32)(addr);
            if (entitySlots[addr] == null) {
                entitySlots[addr] = new Set();
            }
            const currentEntitySlots = entitySlots[addr];
            // valid slot: the slot was generated by keccak(entityAddr || ...)
            if (k.startsWith(addrPadded)) {
                // console.log('added mapping (balance) slot', value)
                currentEntitySlots.add((0, utils_1.keccak256)(k));
            }
            // disabled 2nd rule: .. or by keccak( ... || OWN) where OWN is previous allowed slot
            // if (k.length === 130 && currentEntitySlots.has(k.slice(-64))) {
            //   // console.log('added double-mapping (allowance) slot', value)
            //   currentEntitySlots.add(value)
            // }
        });
    });
    return entitySlots;
}
/**
 * parse collected simulation traces and revert if they break our rules
 * @param userOp the userOperation that was used in this simulation
 * @param tracerResults the tracer return value
 * @param validationResult output from simulateValidation
 * @param entryPoint the entryPoint that hosted the "simulatedValidation" traced call.
 * @return list of contract addresses referenced by this UserOp
 */
function parseScannerResult(userOp, tracerResults, validationResult, entryPoint) {
    debug('=== simulation result:', (0, util_1.inspect)(tracerResults, true, 10, true));
    // todo: block access to no-code addresses (might need update to tracer)
    const entryPointAddress = entryPoint.address.toLowerCase();
    const bannedOpCodes = new Set(['GASPRICE', 'GASLIMIT', 'DIFFICULTY', 'TIMESTAMP', 'BASEFEE', 'BLOCKHASH', 'NUMBER', 'SELFBALANCE', 'BALANCE', 'ORIGIN', 'GAS', 'CREATE', 'COINBASE', 'SELFDESTRUCT', 'RANDOM', 'PREVRANDAO']);
    // eslint-disable-next-line @typescript-eslint/no-base-to-string
    if (Object.values(tracerResults.numberLevels).length < 2) {
        // console.log('calls=', result.calls.map(x=>JSON.stringify(x)).join('\n'))
        // console.log('debug=', result.debug)
        throw new Error('Unexpected traceCall result: no NUMBER opcodes, and not REVERT');
    }
    const callStack = parseCallStack(tracerResults);
    const callInfoEntryPoint = callStack.find(call => call.to === entryPointAddress && call.from !== entryPointAddress &&
        (call.method !== '0x' && call.method !== 'depositTo'));
    (0, utils_2.requireCond)(callInfoEntryPoint == null, `illegal call into EntryPoint during validation ${callInfoEntryPoint === null || callInfoEntryPoint === void 0 ? void 0 : callInfoEntryPoint.method}`, Types_1.ValidationErrors.OpcodeValidation);
    (0, utils_2.requireCond)(callStack.find(call => {
        var _a;
        return call.to !== entryPointAddress &&
            ethers_1.BigNumber.from((_a = call.value) !== null && _a !== void 0 ? _a : 0) !== ethers_1.BigNumber.from(0);
    }) != null, 'May not may CALL with value', Types_1.ValidationErrors.OpcodeValidation);
    const sender = userOp.sender.toLowerCase();
    // stake info per "number" level (factory, sender, paymaster)
    // we only use stake info if we notice a memory reference that require stake
    const stakeInfoEntities = {
        factory: validationResult.factoryInfo,
        account: validationResult.senderInfo,
        paymaster: validationResult.paymasterInfo
    };
    const entitySlots = parseEntitySlots(stakeInfoEntities, tracerResults.keccak);
    Object.entries(stakeInfoEntities).forEach(([entityTitle, entStakes], index) => {
        var _a, _b, _c, _d;
        const entityAddr = (_a = entStakes === null || entStakes === void 0 ? void 0 : entStakes.addr) !== null && _a !== void 0 ? _a : '';
        const currentNumLevel = tracerResults.numberLevels[index];
        const opcodes = currentNumLevel.opcodes;
        const access = currentNumLevel.access;
        (0, utils_2.requireCond)(!((_b = currentNumLevel.oog) !== null && _b !== void 0 ? _b : false), `${entityTitle} internally reverts on oog`, Types_1.ValidationErrors.OpcodeValidation);
        Object.keys(opcodes).forEach(opcode => (0, utils_2.requireCond)(!bannedOpCodes.has(opcode), `${entityTitle} uses banned opcode: ${opcode}`, Types_1.ValidationErrors.OpcodeValidation));
        if (entityTitle === 'factory') {
            (0, utils_2.requireCond)(((_c = opcodes.CREATE2) !== null && _c !== void 0 ? _c : 0) <= 1, `${entityTitle} with too many CREATE2`, Types_1.ValidationErrors.OpcodeValidation);
        }
        else {
            (0, utils_2.requireCond)(opcodes.CREATE2 == null, `${entityTitle} uses banned opcode: CREATE2`, Types_1.ValidationErrors.OpcodeValidation);
        }
        Object.entries(access).forEach(([addr, { reads, writes }]) => {
            // testing read/write access on contract "addr"
            if (addr === sender) {
                // allowed to access sender's storage
                return;
            }
            if (addr === entryPointAddress) {
                // ignore storage access on entryPoint (balance/deposit of entities.
                // we block them on method calls: only allowed to deposit, never to read
                return;
            }
            // return true if the given slot is associated with the given address, given the known keccak operations:
            // @param slot the SLOAD/SSTORE slot address we're testing
            // @param addr - the address we try to check for association with
            // @param reverseKeccak - a mapping we built for keccak values that contained the address
            function associatedWith(slot, addr, entitySlots) {
                const addrPadded = (0, utils_1.hexZeroPad)(addr, 32).toLowerCase();
                if (slot === addrPadded) {
                    return true;
                }
                const k = entitySlots[addr];
                if (k == null) {
                    return false;
                }
                const slotN = ethers_1.BigNumber.from(slot);
                // scan all slot entries to check of the given slot is within a structure, starting at that offset.
                // assume a maximum size on a (static) structure size.
                for (const k1 of k.keys()) {
                    const kn = ethers_1.BigNumber.from(k1);
                    if (slotN.gte(kn) && slotN.lt(kn.add(128))) {
                        return true;
                    }
                }
                return false;
            }
            debug('dump keccak calculations and reads', {
                entityTitle,
                entityAddr,
                k: (0, utils_2.mapOf)(tracerResults.keccak, k => (0, utils_1.keccak256)(k)),
                reads
            });
            // scan all slots. find a referenced slot
            // at the end of the scan, we will check if the entity has stake, and report that slot if not.
            let requireStakeSlot;
            [...Object.keys(writes), ...Object.keys(reads)].forEach(slot => {
                // slot associated with sender is allowed (e.g. token.balanceOf(sender)
                // but during initial UserOp (where there is an initCode), it is allowed only for staked entity
                if (associatedWith(slot, sender, entitySlots)) {
                    if (userOp.initCode.length > 2) {
                        requireStakeSlot = slot;
                    }
                }
                else if (associatedWith(slot, entityAddr, entitySlots)) {
                    // accessing a slot associated with entityAddr (e.g. token.balanceOf(paymaster)
                    requireStakeSlot = slot;
                }
                else if (addr === entityAddr) {
                    // accessing storage member of entity itself requires stake.
                    requireStakeSlot = slot;
                }
                else {
                    // accessing arbitrary storage of another contract is not allowed
                    const readWrite = Object.keys(writes).includes(addr) ? 'write to' : 'read from';
                    (0, utils_2.requireCond)(false, `${entityTitle} has forbidden ${readWrite} ${nameAddr(addr, entityTitle)} slot ${slot}`, Types_1.ValidationErrors.OpcodeValidation, { [entityTitle]: entStakes === null || entStakes === void 0 ? void 0 : entStakes.addr });
                }
            });
            // if addr is current account/paymaster/factory, then return that title
            // otherwise, return addr as-is
            function nameAddr(addr, currentEntity) {
                var _a;
                const [title] = (_a = Object.entries(stakeInfoEntities).find(([title, info]) => (info === null || info === void 0 ? void 0 : info.addr.toLowerCase()) === addr.toLowerCase())) !== null && _a !== void 0 ? _a : [];
                return title !== null && title !== void 0 ? title : addr;
            }
            requireCondAndStake(requireStakeSlot != null, entStakes, `unstaked ${entityTitle} accessed ${nameAddr(addr, entityTitle)} slot ${requireStakeSlot}`);
        });
        if (entityTitle === 'paymaster') {
            const validatePaymasterUserOp = callStack.find(call => call.method === 'validatePaymasterUserOp' && call.to === entityAddr);
            const context = (_d = validatePaymasterUserOp === null || validatePaymasterUserOp === void 0 ? void 0 : validatePaymasterUserOp.return) === null || _d === void 0 ? void 0 : _d.context;
            requireCondAndStake(context != null && context !== '0x', entStakes, 'unstaked paymaster must not return context');
        }
        // helper method: if condition is true, then entity must be staked.
        function requireCondAndStake(cond, entStake, failureMessage) {
            if (!cond) {
                return;
            }
            if (entStakes == null) {
                throw new Error(`internal: ${entityTitle} not in userOp, but has storage accesses in ${JSON.stringify(access)}`);
            }
            (0, utils_2.requireCond)(ethers_1.BigNumber.from(1).lt(entStakes.stake) && ethers_1.BigNumber.from(1).lt(entStakes.unstakeDelaySec), failureMessage, Types_1.ValidationErrors.OpcodeValidation, { [entityTitle]: entStakes === null || entStakes === void 0 ? void 0 : entStakes.addr });
            // TODO: check real minimum stake values
        }
        (0, utils_2.requireCond)(Object.keys(currentNumLevel.contractSize).find(addr => currentNumLevel.contractSize[addr] <= 2) == null, `${entityTitle} accesses un-deployed contract ${JSON.stringify(currentNumLevel.contractSize)}`, Types_1.ValidationErrors.OpcodeValidation);
    });
    // return list of contract addresses by this UserOp. already known not to contain zero-sized addresses.
    const addresses = tracerResults.numberLevels.flatMap(level => Object.keys(level.contractSize));
    const storageMap = {};
    tracerResults.numberLevels.forEach(level => {
        Object.keys(level.access).forEach(addr => {
            var _a;
            storageMap[addr] = (_a = storageMap[addr]) !== null && _a !== void 0 ? _a : level.access[addr].reads;
        });
    });
    return [addresses, storageMap];
}
exports.parseScannerResult = parseScannerResult;
//# sourceMappingURL=parseScannerResult.js.map